---
title: 100 Days of Code - Day 1
description: Learn, code, and share, everyday
date: 2020-05-12
tags: 
  - 100DaysOfCode
layout: layouts/post.njk
---

For the next 100 days, I will 1. code for 1-hour (minumum), 2. [tweet](https://twitter.com/hashtag/100DaysOfCode) my progress with the #100DaysOfCode hashtag, and 3. post my work for others to see.

### Day 1: May 12, 2020

#### Today's Progress

Took Kyle Simpson's [JavaScript: The Recent Parts](https://frontendmasters.com/courses/js-recent-parts/) and learned about new features of ES2016 - ES2019. We learned about template strings, tagged templates, array & object destructuring, iterators, and generators. Tomorrow, I plan to finish sections on regular expressions and Async Await. I also revamped *this* blog to be the home for this challenge.

#### Thoughts

Something Kyle is good at is contextualizing information. He does a great job of giving you enough information to know what makes a new feature special and the old (imperative) approaches to JavaScript.

#### Work examples

##### Array Destructuring

A rest operator will give us an empty array if there isn't any data to collect:

```js
function data() {
  return [1, 2, 3];
}

var [first, second, third, ...fourth] = data();

console.log(fourth); // logs []
```

Sometimes you want to collect a reference to the original data and destructure it:

```js
function data() {
  return [1, 2, 3, 4, 5];
}
var temp;
var [first, second, third, ...rest] = (temp = data());
console.log(temp); // [1, 2, 3, 4, 5]
```

Use array destructuring to swap values:

```js
var x = 10;
var y = 20;

[ y, x ] = [ x, y ]
```

Avoid errors with fallback values:

```js
function data(tmp) {
  return null;
}

var temp;
var [first, , third, ...rest] = (temp = data() || []);
```

##### Object Destructuring

The destructuring pattern goes `source: target = defaultValue`

```js
function data() {
  return {
    a: 1,
    b: 2,
    c: 3,
  };
}

var { a: first = 0 } = data();
```

Use `...` to collect remaining properties into their own object:

```js
function data() {
  return {
    a: 1,
    b: 2,
    c: 3,
  };
}

var { a: first, ...rest } = data();
console.log(rest); // logs { b: 2, c: 3 }
```

We have to wrap the destructuring in `()` if we already declared a variable during destructuring:

```js
function data() {
  return {
    a: 1,
    b: 2,
    c: 3,
  };
}

var first, second;

({ 
	a: first, 
	b: second 
} = data());
console.log(first); // 1
```

Similar to array destructuring, we can use default assignment to avoid exceptions:

```js
function data() {
  // return {
  //   a: 1,
  //   b: 2,
  //   c: 3,
  // };
  return null;
}

var {
  a: first,
  b: second
} = data() || {};
console.log(first); // undefined
```

It's a good idea to get into the habit of using default values for everything in destructuring:

```js
var o3 = null;
var {
  a: {
    b = 10,
    c = 20
  } = {}
} = o3
```

##### Miscellaneous Destructuring

We can leverage object destructuring in function parameters too. This allows us to ignore parameter position and instead rely on its name:

```js
function lookupRecord({
  store = 'person-records',
  id = -1
}) {
  console.log(store);
  console.log(id);
}

```

Destructuring can even be used to create our own *extends* function. An *extends* function merges two objects and replaces default property values with our own values:

```js
function fetchOptions({
  url = 'http://some-url.com',
  method = 'post',
  data,
  callback,
  headers: [
    headers0 = 'Content-Type: text/plain', 
    ...otherHeaders
  ] = [],
} = {}) {
  return {
    url,
    method,
    data,
    callback,
    headers: [
      headers0, 
      ...otherHeaders
    ],
  };
}
```

##### Array Methods

`.find()`returns the value of the first element that returns true from a provided callback testing function. We can use this method to implement custom search functionality. If find doesn't find a value that matches the testing condition then it returns `undefined`. That's a problem if you want to search for a value of `undefined`

We can use `.findIndex()` to get around the problem of searching for the value `undefined`.

`.includes()` allows us to test if a value exists in an array. This method uses a more robust algorithm and can be used to find `NaN` values.

`.flat()` is used to flatten arrays (remove sub-arrays). We can pass it a number to determine the number of levels we want to flatten. We can pass it `infinity` to flatten completely.

`.flatMap()` allows us to do a `.flat()` `.map()` wombo combo. `flatMap()` will only go one level deep but it can be used to add & remove elements from an array (unlike a normal `.map()` function):

```js
[1, 2, 3, 4, 5, 6].flatMap(function doubleNums(v) {
  if (v % 2 == 0) {
    return [v, v * 2];
  } else {
    return [];
  }
}); // returns [ 2, 4, 4, 8, 6, 12 ]
```